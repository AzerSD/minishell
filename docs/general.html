<h1>The First Step</h1>
1. The first step was making a very simple version of shell.<br>
A while loop that keeps asking for input until you type 'exit'<br>
<ul>
    <li>Print a PromptString(PS) e.g "&gt;", "$".</li>
    <li>Read a line of input (get_next_line):<br>
        cmd = get_next_line()<br>
        if (cmd == exit) break;<br>
        else printf(cmd);
    </li>
</ul>
<p>I made some changed on top of get_next_line to be able to detect escape characters so I can keep reading input even
    if I press enter after an input like: "abc \", "\"...</p>


<h1>What's Next?</h1>
Now that we can read a command line, Logically the next step would be to execute the command line or atleast a very
basic command. but first we need to understand what is a command.<br><br>

A basic command consists of a list of words separated by whitespaces.<br>
The first word is the command name(mandatory), the other words are optional(arguments)<br>
<code>ls -l</code> <code>gcc shell.c -o sh</code> ...
<br><br>
To be able to execute a command we need to:
<ol>
    <li>Scan input character by character to get tokens (Lexical Scanner)</li>
    <li>Extract input tokens (Tokenizer)</li>
    <li>Parse the tokens and create an AST (Parser)</li>
</ol>

<h2>1. Lexical Scanner:</h2>
We need to read our input one character at a time so we can identify the characters that can be part of the token and
those that are delimiter characters. Delimiter characters are the marks of the end of a token and they can be
<b>whitespaces, `;`, `&`, ...</b><br><br>

To easily be able to move around the input for lexical analysis, I created some helper functions to:
<ul>
    <li>Retrieve the next character from input. <code>get_next_char();</code></li>
    <li>Return the last character we've read back to input. <code>unget_char();</code></li>
    <li>Look ahead (peek) to check the next character without returning it. <code>peek_char();</code></li>
    <li>Skip over whitespace characters. <code>skip_whitespace();</code></li>
</ul>
And to make the job easier, instead of passing the input directly to the scanner, I created a struct `t_cli` that will
have a copy of our input and its length and the cursor position. So each time I have some job for the input I use that
`t_cli`

<div>
    <h2>2. Tokenizing Input:</h2>
    <p>Now we'll use the Scanner functions to extract input tokens</p>
    <ul>
        <li>I started by defining a struct to hold a single token <code>t_token</code> which will hold the input, size
            of input, and token text.</li>
        <li>Write the tokenize function which will retrieve the next token from input for that I need some helper
            functions and a helper struct to hold our token and it's size and it's index.</li>
        <ul>
            <li><code>add_to_buff()</code>: adds a single character to the token buffer</li>
            <li><code>create_token()</code>: convert a string to a token AKA <code>t_token</code></li>
            <li><code>free_token()</code></li>
            <li><code>tokenize()</code>: uses the previous helper function to initialize our token, keep retrieving next
                char until we reach an end of a delimiter, and we got our first token, keep doing that and we get all
                tokens</li>
        </ul>
    </ul>

    <h2>3. Parse The Tokens:</h2>
    <p>
        This part will use the lexical scanner functions to retrieve tokens and construct the AST that will be passed to
        the executor.
        For now the parser is one command called <code>execc</code>

        result: execute commands with any number of parameters
    </p>
    <h2>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html">
            - Symbol Table:
        </a>
    </h2>
    <p>The symbol table is a data structure that is used by compilers and interpreters to store variables as entries in
        the table. Each entry consists of a key (the variable’s name) and an associated value (the variable’s value).
        Keys are usually unique, that is, we can’t have two entries that share the same key (i.e., can’t have two
        variables that share the same variable name).
        Typically, a Linux shell populates its symbol table on startup. After populating the symbol table, the compiler
        or interpreter can easily search for a variable in the table to retrieve that variable’s value
        To populate the symbol table, the shell reads the environment variables list, which is passed to the shell from
        its parent process (usually the process that logged the user in, or a child process of the login process). The
        shell adds each variable (and its value) to the symbol table. Afterwards, we can edit, remove, or export shell
        variables at will, using the proper builtin utilities

        resutl: we'll be able to define shell variables, modify their values, use the values of different shell
        variables when we perform variable expansion, and export variables to external commands. The symbol table will
        also become handy when we talk about positional and special shell parameters later on in this series.
    </p>

    <h2>
        <a
            href="https://www.gnu.org/software/libc/manual/html_node/Word-Expansion.html#:~:text=Word%20expansion%20means%20the%20process%20of%20splitting%20a,is%20the%20most%20basic%20function%20of%20word%20expansion.">
            - Word Expansion:
        </a>
    </h2>
    <p>
        is the process by which the shell takes a command word, checks it to see if it contains variable names,
        pathnames, commands, and arithmetic expressions, and substitutes each name/command/expression with its value.
        The resultant word, which is usually (but not always) longer than the original word, might be broken down into
        one or more subwords (or fields), in a process known as field splitting.
    </p>
    <p>
        The are 7 types of work expansion which is defined by POSIX
    <ol>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html#Tilde-Expansion">
            <ul> tilde expansion </ul>
        </a>
        <a
            href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion">
            <ul> parameter expansion </ul>
        </a>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html#Arithmetic-Expansion">
            <ul> arithmetic expansion </ul>
        </a>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html#Command-Substitution">
            <ul> command substitution </ul>
        </a>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html#Word-Splitting">
            <ul> field splitting </ul>
        </a>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion">
            <ul> pathname expansion </ul>
        </a>
        <a href="https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html#Quote-Removal">
            <ul> quote removal </ul>
        </a>
    </ol>